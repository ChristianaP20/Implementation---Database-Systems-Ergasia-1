Για την δημιουργία του εκτελέσιμου το οποίο δείχνει
τις δυνατότητες της βιβλιοθήκης BF, τρέξτε την εντολή:

make bf;

Για να τρέξετε το εκτελέσιμο:

./build/bf_main

Αντίστοιχα και για τα άλλα εκτελέσιμα.
make ht;
make hp;

HP Functions:
•	HP_CreateFile:
Για την δημιουργία του αρχείου σορού στην ουσία δεσμεύουμε μνήμη για το πρώτο Block ώστε να αποθηκεύσουμε μέσα τα meta data τα οποία είναι το HP_info και το HP_block_info όπου μέσα στο HP_infο κρατάμε τα εξής δεδομένα: (fileDesc (αναγνωριστικός αριθμός αρχείου) τύπου int , block(το μπλοκ που είναι αποθηκευμένο το HP_info) τύπου BF_Block,  last_block_id(το id του τελευταίου μπλοκ που δημιουργήθηκε) τύπου int,  records_block_size(ο αριθμός εγγραφών που χωράνε μέσα στα blocks) τύπου int,  flag(ένα αναγνωριστικό μήνυμα ώστε να αναγνωρίζουμε το αρχείο) τύπου char) και το HP_block_info έχει τα εξής δεδομένα: (record_block_size(ο αριθμός των εγγραφών που έχει το συγκεκριμένο block)). Έπειτα, αφού αρχικοποιησουμε  τα meta data μας τα αποθηκεύουμε στο block με τέτοιο τρόπο ώστε όταν τα χρειαστούμε να ξέρουμε από πιο σημείο του block θα τραβήξουμε τα meta data.

•	HP_OpenFile;
Στο άνοιγμα του αρχείου παίρνουμε τα meta data από το πρώτο μπλοκ και πιο συγκεκριμένα το HP_info ώστε να επιβεβαιώσουμε ότι αυτό είναι το heap File και αν όντως είναι τότε εμφανίζουμε κατάλληλο μήνυμα και επιστρέφουμε την HP_info.

•	HP_CloseFile:
Κλείνουμε το αρχείο μέσω μια κατάλληλης μεθόδου την BF_CloseFile όπου παίρνει σας όρισμα τον αναγνωριστικό αριθμό του αρχείου και αποδεσμεύουμε και την μνήμη που είχαμε για το hp_info.

•	HP_InsertEntry:
Για την εισαγωγή της εγγραφής μέσα στο block κρατάμε δυο στατικές μεταβλητές μια για της πόσες εγγραφές έχουν μπει μέσα στο block και μια για να δούμε σε πιο block είμαστε (την στατική μεταβλητή για το πόσες εγγραφές έχουμε μέσα στο συγκεκριμένο block θα μπορούσαμε να την αφαιρέσουμε τελείως καθώς έχουμε το record_block_size aπο την HP_block_info). Έπειτα, όταν μια εγγραφή μπει στο block τότε αυξάνετε το slot κατά 1 και μετα η τιμη του slot μπαινει στην record_block_size της HP_block_info. Όταν το block γεμίσει τότε μηδενίζουμε το slot και αυξάνουμε το block_counter κατά 1 τότε στην επόμενη εγγραφή που είναι να γίνει insert θα γίνει έλεγχος αν είναι άδειο το block και αν ναι τότε γίνεται allocate καινούργιο block και προχωράει η διαδικασία.

•	HP_GetAllEntries:
Για να βρω τις εγγραφές που έχουν ίδιο record.id με το value γίνεται η εξής διαδικασία: Κρατάω ξανά μια μεταβλητή όπου προσδιορίζει από πιο block θα ξεκινήσουμε να ψάχνουμε. Στην προκείμενή περίπτωση το αρχικοποιουμε με 1 διότι στο πρώτο block έχουμε τα metadata του αρχείου μας. Έπειτα, κάνουμε επαναλήψεις τόσες όσα είναι τα blocks καθώς μέσα στις επαναλήψεις παίρνουμε το block_info του block ώστε να δούμε πόσες εγγραφές έχει και να κάνουμε επανάληψη τόσες όσες είναι οι εγγραφές ώστε να ελέγξουμε αν είναι υπάρχει το record το οποίο αναζητούμε. Αν βρεθεί τότε εμφανίζουμε όλες τις εγγραφές με το επιθυμητό value και αυξάνουμε τον block_counter για να  πάμε και στα επόμενα blocks. Τέλος, αν όλα πάνε καλά επιστρέφουμε το πλήθος των block που διαβάσαμε για να βρούμε όλες τις εγγραφές διαφορετικά επιστέφουμε -1 ως λάθος.
